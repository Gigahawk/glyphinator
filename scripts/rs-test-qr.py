#!/usr/bin/python3
###############################################################################
# rs-test-qr.py -- reed solomon test calculator for quick response
###############################################################################
# Copyright 2017 Chris Baker
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
###############################################################################

#Example: Version 1 High ECC: byte mode "Ver1"
data=bytearray((64, 69, 102, 87, 35, 16))
ecc_size=17
data_size=26-ecc_size

#Example: Version 2 High ECC: byte mode "Version 2"
data=bytearray((64, 149, 102, 87, 39, 54, 150, 246, 226, 3, 32))
ecc_size=28
data_size=44-ecc_size

#Example: Version 3 Low ECC: byte mode "Mr. Watson, come here - I want to see you."
data=bytearray((66, 164, 215, 34, 226, 5, 118, 23, 71, 54, 246, 226, 194, 6, 54, 246, 214, 82, 6, 134, 87, 38, 82, 2, 210, 4, 146, 7, 118, 22, 231, 66, 7, 70, 242, 7, 54, 86, 82, 7, 150, 247, 82, 224))
ecc_size=15
data_size=70-ecc_size

print("data bytes:", end=" ")
for i in data: print(i,end=",")
print()

pad_start=len(data)

# Calculate padding bytes
for i in range(data_size-pad_start):
	data.append(236 if (i%2==0) else 17)

print("pad bytes:", end=" ")
for i in data[pad_start:data_size]: print(i,end=",")
print()


# The algorithms
# based on notes from [grandzebu.net](http://grandzebu.net/informatique/codbar-en/datamatrix.htm)
# and [barcode-coder.com](http://barcode-coder.com/en/datamatrix-specification-104.html)

# The quick response reed-solomon calculations operate in a Galois Field,
# GF(2^8) with primitive polynomial 285.
# The arithmetic operations are XOR and Multiplication

# Multiplication implemented with Galois log and antilog.
# Mult(a,b) = Alog((Log(a) + Log(b)) Mod 255)
# Precomputed arrays:
galois_log=(-255,255,1,25,2,50,26,198,3,223,51,238,27,104,199,75,4,100,224,14,52,141,239,129,28,193,105,248,200,8,76,113,5,138,101,47,225,36,15,33,53,147,142,218,240,18,130,69,29,181,194,125,106,39,249,185,201,154,9,120,77,228,114,166,6,191,139,98,102,221,48,253,226,152,37,179,16,145,34,136,54,208,148,206,143,150,219,189,241,210,19,92,131,56,70,64,30,66,182,163,195,72,126,110,107,58,40,84,250,133,186,61,202,94,155,159,10,21,121,43,78,212,229,172,115,243,167,87,7,112,192,247,140,128,99,13,103,74,222,237,49,197,254,24,227,165,153,119,38,184,180,124,17,68,146,217,35,32,137,46,55,63,209,91,149,188,207,205,144,135,151,178,220,252,190,97,242,86,211,171,20,42,93,158,132,60,57,83,71,109,65,162,31,45,67,216,183,123,164,118,196,23,73,236,127,12,111,246,108,161,59,82,41,157,85,170,251,96,134,177,187,204,62,90,203,89,95,176,156,169,160,81,11,245,22,235,122,117,44,215,79,174,213,233,230,231,173,232,116,214,244,234,168,80,88,175)
galois_antilog=(1,2,4,8,16,32,64,128,29,58,116,232,205,135,19,38,76,152,45,90,180,117,234,201,143,3,6,12,24,48,96,192,157,39,78,156,37,74,148,53,106,212,181,119,238,193,159,35,70,140,5,10,20,40,80,160,93,186,105,210,185,111,222,161,95,190,97,194,153,47,94,188,101,202,137,15,30,60,120,240,253,231,211,187,107,214,177,127,254,225,223,163,91,182,113,226,217,175,67,134,17,34,68,136,13,26,52,104,208,189,103,206,129,31,62,124,248,237,199,147,59,118,236,197,151,51,102,204,133,23,46,92,184,109,218,169,79,158,33,66,132,21,42,84,168,77,154,41,82,164,85,170,73,146,57,114,228,213,183,115,230,209,191,99,198,145,63,126,252,229,215,179,123,246,241,255,227,219,171,75,150,49,98,196,149,55,110,220,165,87,174,65,130,25,50,100,200,141,7,14,28,56,112,224,221,167,83,166,81,162,89,178,121,242,249,239,195,155,43,86,172,69,138,9,18,36,72,144,61,122,244,245,247,243,251,235,203,139,11,22,44,88,176,125,250,233,207,131,27,54,108,216,173,71,142,1)

##Above arrays generated by:
#galois_log={}
#galois_log[0]=-255
#galois_antilog=[]
#galois_antilog.append(1)
#for i in range(1,256):
#	galois_antilog.append(galois_antilog[i-1]*2)
#	if (galois_antilog[i] >= 256):
#		galois_antilog[i] = galois_antilog[i]^285
#	galois_log[galois_antilog[i]] = i
#print("galois_log=(", end="")
#for i in range(0,256):
#	print(galois_log[i],end=",")
#print(")")
#print("galois_antilog=(", end="")
#for i in range(0,256):
#	print(galois_antilog[i],end=",")
#print(")")

def galois_mult(a, b):
	return galois_antilog[(galois_log[a]+galois_log[b])%255]

def galois_pow(a, b):
	if (b==0): return 1
	if (b==1): return a
	r=a
	for i in range(b-1):
		r=galois_mult(r,a)
	return r

#these are computed factor table for GF(2^8) poly 285
#the key is the number of ecc bytes
factor_tables={
#1L
 7:bytes((117,68,11,164,154,122,127)),
#1M, 2L
10:bytes((193,157,113,95,94,199,111,159,194,216)),
#1Q
13:bytes((120,132,83,43,46,13,52,17,177,17,227,73,137)),
#3L
15:bytes((26,134,32,151,132,139,105,105,10,74,112,163,111,196,29)),
#2M, 4H, 6M
16:bytes((59,36,50,98,229,41,65,163,8,30,209,68,189,104,13,59)),
#1H
17:bytes((79,99,125,53,85,134,143,41,249,83,197,22,119,120,83,66,119)),
#3Q, 4M, 5Q, 6L
18:bytes((146,217,67,32,75,173,82,73,220,240,215,199,175,149,113,183,251,239)),
#4L
20:bytes((174,165,121,121,198,228,22,187,36,69,150,112,220,6,99,111,5,240,185,152)),
#2Q, 5H
22:bytes((245,145,26,230,218,86,253,67,123,29,137,28,40,69,189,19,244,182,176,131,179,89)),
#5M, 6Q
24:bytes((117,144,217,127,247,237,1,206,43,61,72,130,73,229,150,115,102,216,237,178,70,169,118,122)),
#3M, 4Q, 5L
26:bytes((94,43,77,146,144,70,68,135,42,233,117,209,40,145,24,206,56,77,152,199,98,136,4,183,51,246)),
#2H, 6H
28:bytes((197,58,74,176,147,121,100,181,127,233,119,117,56,247,12,167,41,100,174,103,150,208,251,18,13,28,9,252)),
#Version 9 and higher
30:bytes((150,130,106,11,195,216,74,228,46,18,25,72,246,181,51,138,217,22,177,103,70,5,98,75,192,195,73,77,246,212)),
}

# generate a factor table if it doesn't already exist
# QR differs from data matrix here in that the
# exponentiation is base 0 instead of base 1
def factor_table(ecc_size):
	try:
		return factor_tables[ecc_size]
	except(KeyError):
		factors=bytearray(ecc_size)
		for i in range(ecc_size+1):
			for j in range(i-1,-1,-1):
				factors[j]=galois_mult(factors[j],galois_pow(2,i-1))
				if (j>0):
					factors[j]=factors[j] ^ factors[j-1]
		print("**generator factors: ", end=" ");
		for i in factors: print(i,end=",")
		print()
		return factors

f=factor_table(ecc_size)
ecc=bytearray(ecc_size)
t=0

# calculate RS ECC - modified to result in forward byte order
for i in range(data_size):
	t=data[i] ^ ecc[0]
	for j in range(ecc_size):
		if (t==0):
			ecc[j]=0
		else:
			ecc[j]=galois_antilog[(galois_log[t]+galois_log[f[ecc_size-j-1]])%255]
		if ((j+1)<ecc_size):
			ecc[j]=ecc[j+1]^ecc[j]
	#print("int(%d):"%i, end=" ")
	#for k in ecc: print(k,end=" ")
	#print()

print("ecc bytes: ", end=" ")
for i in ecc: print(i,end=",")
print()
